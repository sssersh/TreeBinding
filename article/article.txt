
Загуглить iterate over fields.


Как реализовать итерацию по полям и не обжечься об стандарт.


Мы пишем на С++, поэтому сишные штучки не подходят (посмотреть https://habr.com/ru/company/otus/blog/442554/).
Пишем для С++11 (в С++17 правила для алиасинга вроде сформулированы по-другому, уточнить).


Можно придумать различные методы итерации по полям структуры, которые будут работать. Но при детальном рассмотрении с точки
зрения стандарта окажется, что там присутсвует пресловутое UB.


Чтобы использовать оператор инкремента для итерации по полям, необходимо, чтобы все поля были layout-compatible: имели одинаковый размер и можно было
преобразовывать корректно (почитать подробнее https://en.cppreference.com/w/cpp/language/data_members#Standard_layout).

!!! Вот тут описать шаги, которые нужно сделать, чтобы перейти к следующему полю, а так же какие ограничения нужны, чтобы эти шаги были корректными.
!!! После перечисления ограничений, привести пару методов и сказать, что они не подходят.


(может не добавлять в статью, просто указать, что структура должна удовлетворять st layout)
standard-layout тип:




Почитать про strict aliasing, не нарушает ли мой метод его (https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing)
Наверное нет. Потому что strict aliasing - если пытаться изменить данные через тип, не совместимый с этими данными. 
А у меня доступ к данным только через нужный тип.


Посмотреть слайд 5:
https://llvm.org/devmtg/2017-10/slides/Finkel-The%20Type%20Sanitizer.pdf



Попробуем применить каламбур типизации:



Метод 1:

Если использовать для итерации по полям такой метод:

Т.е. храним поле в виде данных и пытаемся сдвинуть 

struct Data
{
	Field<int>         intField   ;
	Field<std::string> stringField;
}

Data data;

char* charPtr = static_cast<char*>(&data.intField); // Допустимое преобразование
charPtr += sizeof(data.intField);
std::string* stringPtr = reinterpret_cast<std::string*>(charPtr); // УТОЧНИТЬ: UB: нарушение string aliasing (в общем случае вдобавок - проблемы с выравниванием)



Метод 2:

offsetof(struct Numbers, FirstChar);

Не подходит, т.к. необходимо указывать имя поля.




Источники:

public:
https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8

private:
https://habr.com/ru/company/otus/blog/442554/

